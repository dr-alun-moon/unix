%&pdflatex
\documentclass{article}
\usepackage[
    includeall,
    marginpar=1.5in,
    hscale=0.707,vscale=0.9
    ]{geometry}
\title{Unix Shell scripting}
\author{Dr Alun Moon}
\usepackage[svgnames]{xcolor}

\usepackage[british]{babel}
\usepackage{siunitx,minted}
\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage[skins]{tcolorbox}
%\tcbset{enhanced,colframe=ExampleFrame!70!black,colback=ExampleBack!10,drop fuzzy shadow}

\usepackage{theorem}
\theorembodyfont{\upshape}
\newtheorem{exercise}{Exercise:}
\newtheorem{question}{Question:}
\usepackage{hyperref}
\hypersetup{%
  colorlinks,
  urlcolor = DarkRed,
}%


\pagestyle{headings}
\begin{document}
\maketitle
%\tableofcontents
\section{Introduction}
\paragraph{Shell scripts} in Unix are a very powerfull tool, they
form much of the standard system as installed.  Many file handling and
administrative tasks are aided and automated by use of shell scripts.

\subsection{Spaces}
In some places spaces in the bash script are important.  Where
necessary these will be shown as a \verb*| | symbol, for example
\verb*'if [ -f name'

\subsection{Editing}
\paragraph{A Script is just a text file containing a sequence of
  commands.}  These are performed as if typed from the command line.
Since the script is just plain text, it can be edited with just about any
editor.  It can also be manipulated, archived, indexed, and managed under
version control,  just like any other file or program.

\subsection{Executing a script}
When you type a command at the shell prompt, there are two steps the shell
takes to find and execute the command.
\begin{enumerate}
	\item locates a file with a name that matches the command.
		\begin{itemize}
			\item If the command starts with a \verb'/', or a relative
				pathname, the file named is used.
			\item For a single word command, a list of directories is searched
				for a file that matches the name.  This list is held in the
				\verb'PATH' environment variable.
		\end{itemize}
	\item attempts to execute the file.
		\begin{itemize}
			\item The execute permission bit for the user entering the command
				\textbf{must} be set.
		\end{itemize}
\end{enumerate}


\clearpage\section{Creating a shell script}
A shell script is just a text file, so any good text editor will do.  I use
\verb'vi', but that is a matter of familiarity.  Another good editor for use
on the terminal is \verb'nano'.  The file just contains commands, just as if typed in at the terminal.


\paragraph{For example:} the following script is put in a file \texttt{ascript}
  \begin{tcolorbox}[title=script \texttt{ascript}]
    \verbatiminput{scripts/ascript}
  \end{tcolorbox}

\paragraph{The file has to have its execute bit set } in order for it
to be used as a command
\begin{tcolorbox}[colframe=Green]
\begin{minted}{shell-session}
$ chmod +x ascript
$
\end{minted}
\end{tcolorbox}
It can now be run like any other unix command
\begin{tcolorbox}[colframe=Green]
\begin{minted}{shell-session}
$ ./ascript
$
\end{minted}
\end{tcolorbox}
The execute bit needs only setting the once.

\begin{tcolorbox}[colframe=Green]
\begin{minted}{shell-session}
$ vi ascript
$ chmod +x ascript
$ ./ascript
Tue  4 Dec 12:25:13 GMT 2018
cgam1
/home/cgam1/unix/scripts
$ vi ascript
$ ./ascript
Tue  4 Dec 12:26:02 GMT 2018
cgam1
/home/cgam1/unix/scripts
$
\end{minted}
\end{tcolorbox}

\paragraph{shebang line}
There is a convention that scripts start with a \emph{shebang} line, that
starts with a \verb'#!' pair of characters.
\begin{tcolorbox}
\begin{minted}{bash}
#!/bin/bash
\end{minted}
\end{tcolorbox}
The line is used to give the interpreter used for the file.  It allows shell
scripts to be written in a variety of languages, bash shell, python, sed, awk,
etc.

\section{Directories and the Working Directory}
The concept of the working directory is important when working with
files and scripts.  The shell can be thought of as being in the
\emph{current working directory} commands that operate on files use
this as the default directory.

For example \texttt{ls} with no parameters lists the files in the
working directory.

\paragraph{To change the working directory.}  use the \texttt{cd}
$\langle$\emph{directory name}$\rangle$ command

\paragraph{To find the current working directory} use the
\texttt{pwd} command.  Usually the modern convention is to have the
prompt show the working directory\marginpar{or sometimes the last
  folder in the working directory}.  The \texttt{pwd} command is
useful to use in scripts.

\paragraph{When referring to files} it is in relation to the
\emph{working directory}\marginpar{Some editors default to the
  \textsf{Documents} directory.  If your script is saved there you
  will need to \texttt{cd Documents} to make this the working
  directory}.
A plain file-name refers to a file in the working directory.  A name
prefixed with a directory name (\texttt{directory/file}) it refers to
a file in that sub-directory.

\subsection{Aside on missing files}
Try the following in the command shell
\begin{minted}[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}
mkdir folder
cp *.h folder
\end{minted}
You should get an error as follows
\begin{minted}[frame=leftline,rulecolor=\color{Navy},framerule=1pt]{shell-session}
shell$ mkdir folder
shell$ cp *.h folder
cp: cannot stat '*.h': No such file or directory
\end{minted}
The problem is that there are no files ending in a \textsf{.h}, the
exact reason for the error is dependent on the way the shell handles
the \textsf{*.h}

\section{Command-line parameters }
We want to be able to make scripts that can be given parameters, such
as a directory name.  We can call these like any other command
\begin{minted}[frame=leftline,rulecolor=\color{Navy},framerule=1pt]{bash}
scriptname foldername filename
\end{minted}
These are accessed using special variables
\texttt{\$0}\ldots\texttt{\$9}
\begin{exercise}
  Try the following script, take care with the quotes
  \inputminted[label=ascript,frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/name}
Then use the following parameters running the script from the shell
\begin{minted}[frame=leftline,rulecolor=\color{Green},framerule=3pt]{text}
names
names fred
names fred flintstone
\end{minted}
Note how variables that have not been set are expanded
\end{exercise}

\paragraph{Parameters can be used in any way}
\begin{exercise}Create a script \texttt{initf}
    \inputminted[label=ascript,frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/initf}
Then try it with
\begin{minted}[frame=leftline,rulecolor=\color{Green},framerule=3pt]{text}
intif .
mkdir folder
initf folder
initf
\end{minted}
\begin{question}
  What is the meaning of the dot \texttt{.} as a directory name?
\end{question}
\begin{question}
  Without parameters, why does the script fail?
\end{question}
\end{exercise}

\section{Variables}
Shell variables are assigned by simply using their name with an equals
sign and a value
\inputminted[frame=leftline,rulecolor=\color{Navy},framerule=1pt]{console}{scripts/vareg}
Note the lack of spaces round the equals sign.

Try
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/varex}

\subsection{User input}
The \texttt{read} command can be used to set variables from used input
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/readex}
\subsection{Variable substitution}
To use a variable prefix it by a dollar sign \texttt{\$}.  The
variable name and its dollar are substituted for by the text stored in
the variable.  If the variable is unset, a blank is substituted.
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/blankex}

\subsection{Arithmetic}
Variable substitution is by the text the variable contains.  If we
want to perform arithmetic we need a different syntax
 \inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/mathex}
By putting the expression inside the \texttt{\$((}\ldots\texttt{))}
several things happen
\begin{enumerate}
\item the value of variables is treated as a number
\item arithmetic operations can take place
\item numeric variables do not use the dollar prefix inside the brackets
\end{enumerate}

\section{Conditional Execution}
The Unix shell gives us the full range of conditional operations.

\paragraph{Logic values} in unix are based on the exit status of
commands\marginpar{technically an exit status of 0 is true, non-0 is
  false}

\subsection{tests}
In order to do logic we need to be able to do tests.  For this we need
a function \texttt{test} (more commonly seen as \texttt{[ ]}) some
common tests are\marginpar{see \texttt{man test}}
\begin{itemize}
\item \verb*:[ -e name ]: the file called name exists
\item \verb*:[ -f name ]: the file name exists and is an ordinary name
\item \verb*:[ -d name ]: the file name exists and is a directory
\item \verb*:[ "string1" = "string2" ]: a string comparison for equality
\item \verb*:[ N -eq M ]: an integer numeric comparison for equality
\end{itemize}
Note the need for spaces in the expressions

\subsection{if\ldots fi}
Try the following
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/life}
Note the spaces in the test and the \texttt{if..then..else..fi}
pattern.  The test is done as a string comparison, note how the
variable expansion is in a string quote.  This avoids the problem
where nothing is entered and the variable expansion is a blank.

\clearpage
\paragraph{We can use these to check that a directory exists before creating it.}
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/dirchk}

\subsection{Multiple choises}
For a multi-way decision the
\texttt{if}\ldots\texttt{then}\ldots\texttt{elif} exists
\inputminted[frame=leftline,rulecolor=\color{Navy},framerule=1pt]{bash}{scripts/ifelif}


\section{Repetition -- loops}
With loops we can perform operations repetitively.

\subsection{while}
We can keep asking a question until a condition is met.
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/liferepr}
Note that the \texttt{do}\ldots\texttt{done} marks the ends of the
section of code repeated for each iteration of the loop

\subsection{shift}
The \texttt{shift} operation modifies the parameters supplied to the
script in \texttt{\$1}, \texttt{\$2}, etc.

Try the following
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/shiftex}
Shift is useful for iterating over a list of parameters
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/shiftsum}

\subsection{for}
The other operation useful for loops is the \texttt{for}.
This takes a list of values and sets a variable to each one in turn.
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/forabc}

\subsection{Backquotes and commands}
The list of values may not be know ahead of time.  What we want is a
way of generating a list of value to put in the code.

We can do this by using file globbing
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/forglob}

We can use the backquote notation to include the output of a command

Put the following in a text file, call the file \texttt{sample.text}
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{text}{scripts/sample.text}



Then try
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/fortext}

There is an alternative notation (that I prefer) that uses the
characters \texttt{\$( )}
\inputminted[frame=leftline,rulecolor=\color{Green},framerule=3pt]{bash}{scripts/fortextalt}



\section{Exercises}
\begin{exercise}
  Write a script to take a list of filenames and write out some
  information about each\marginpar{\textbf{hint:} take a look at the
    \texttt{file} command to identify the file}
\end{exercise}

\begin{exercise}
Write a script to count-down from
10 then write a message ``blast-off''
\end{exercise}

\begin{exercise}
  Write a script to accept two numbers and an arithmetic operator and
  do the calculation, displaying the result. The operators could be +
  - * / \%
\end{exercise}

\begin{exercise}
  Extend these scripts so that they run repeatedly, until the user
  opts to exit.
\end{exercise}

\begin{exercise}
  Write a script supporting a menu system of your own design
\end{exercise}


\clearpage\appendix
\section{POSIX Guidelines}
From ``Utility Syntax Guidelines''
\url{http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02}

\begin{enumerate}
\item Utility names should be between two and nine characters, inclusive.
\item Utility names should include lowercase letters (the lower character classification) and digits only from the portable character set.
\item Each option name should be a single alphanumeric character (the alnum character classification) from the portable character set. The -W (capital-W) option shall be reserved for vendor options.
Multi-digit options should not be allowed.
\item All options should be preceded by the '-' delimiter character.
\item One or more options without option-arguments, followed by at most one option that takes an option-argument, should be accepted when grouped behind one '-' delimiter.
\item Each option and option-argument should be a separate argument, except as noted in Utility Argument Syntax, item (2).
\item Option-arguments should not be optional.
\item When multiple option-arguments are specified to follow a single option, they should be presented as a single argument, using <comma> characters within that argument or <blank> characters within that argument to separate them.
\item All options should precede operands on the command line.
\item The first -- argument that is not an option-argument should be accepted as a delimiter indicating the end of options. Any following arguments should be treated as operands, even if they begin with the '-' character.
\item The order of different options relative to one another should not matter, unless the options are documented as mutually-exclusive and such an option is documented to override any incompatible options preceding it. If an option that has option-arguments is repeated, the option and option-argument combinations should be interpreted in the order specified on the command line.
\item The order of operands may matter and position-related interpretations should be determined on a utility-specific basis.
\item For utilities that use operands to represent files to be opened for either reading or writing, the '-' operand should be used to mean only standard input (or standard output when it is clear from context that an output file is being specified) or a file named -.
\item If an argument can be identified according to Guidelines 3 through 10 as an option, or as a group of options without option-arguments behind one '-' delimiter, then it should be treated as such.
\end{enumerate}

\end{document}


%% Local Variables:
%% mode:tabkey2
%% mode:flyspell
%% mode:reftex
%% End:
